# StreamedBy Madington

## Introduction
StreamedBy is a product developed by Madington. It's a technique that makes playing HD video in display ads possible while keeping bandwidth and network load on a minimum.

StreamedBy makes use of [DASH](https://en.wikipedia.org/wiki/Dynamic_Adaptive_Streaming_over_HTTP) through the [Media Source Extensions Api](https://developer.mozilla.org/en-US/docs/Web/API/Media_Source_Extensions_API), falling back to [HLS](https://developer.apple.com/streaming/) – HTTP Live Streaming – in browsers (eg iOS) that does not support it. When neither technology is available, StreamedBy can fallback to other animation technologies, such as GIFs or javascript/CSS.

This repo is the **central development hub** for StreamedBy, collecting all relevant development resources in one place. It can also function as a **boilerplate or template for new projects**.

## Running project
Run `npm start` to start development (config found in `webpack.dev.js`). To build run `npm run build`.

## Prerequisites
This is a list of software you will need to download and install:

* [FFMpeg](https://www.ffmpeg.org/)
* [MP4Box](https://gpac.wp.imt.fr/mp4box/)

Nice to have:

* AWS Cli
* [Gifsicle](https://www.lcdf.org/gifsicle/)

FFMpeg, MP4Box and Gifsicle are all available through [HomeBrew](https://brew.sh/) which is arguably the easiest way to download and install applications such as these. For instructions on downloading FFMpeg, using HomeBrew, with all available options [click here](https://gist.github.com/Piasy/b5dfd5c048eb69d1b91719988c0325d8).

MP4Box can be downloaded with the formula:

`brew install mp4box`

Gifsicle:

`brew install gifsicle`

## Preparing the video
Start by optimizing the video file for the web. This command is a good start:

`ffmpeg -i input.mp4 -c:v libx264 -s 640x500 -profile:v baseline -level 3.0 -preset slow -crf 23 -movflags faststart -c:a copy output.mp4`

The `-profile:v baseline -level 3.0` bit makes sure backwards compatibility is good (this specific setting will, for example, make the video work on all iOS devices, old as new). The `-crf` (Constant Rate Factor) option is where – together with the resolution (`-s`) – you can cut on file size. The higher the number, the smaller the file. But, of course, also lower quality video. Try to hit the sweet spot; keeping a good quality and not too big of a file. A value somewhere around 23 - 27 often produces ok results.

`-preset slow` makes the process slower but the quality better.

`-movflags faststart` will make the video load a little bit quicker.   

### Removing sound
If sound is not needed, the file size can be considerably reduced by removing the audio tracks form the file. This is done by adding the `-an` flag to the command:

`ffmpeg -i input.mp4 -c:v libx264 -s 640x500 -profile:v baseline -level 3.0 -preset slow -crf 23 -movflags faststart -c:a copy -an output.mp4`

## Chunking the video
Download/clone or `npm install`/`yarn add` [StreamedBy:ify](https://github.com/madington/Madington_StreamedBy-ify). Follow the instructions.

## Building the ad

This is a quick guide to building a StreamedBy ad. Use this project as a template, or just copy the relevant files for use in your own build setup.

Run `npm start` to run the example and have a look in `src/streamedbymadington.js`.

### streamedby.js
**Note** *this is the old way. Check out* **streamedbyfaster.js** *below*.

The foundation of StreamedBy is `modules/streamedby.js`. It exports a function, `StreamedBy`, that will set the streaming source of a video element to either DASH or HLS, pointing to the files we've created in the previous step. It returns a `Promise` and if it rejects, streaming is not possible. Probably because of an outdated or less common browser.

Usage:

```js
import { StreamedBy } from './streamedby'
const videoElem = document.querySelector('video')
const baseUrl = 'https://delivered-by-madington.com/client/customer/campaign/ad/'

StreamedBy(baseUrl, 'the_file_name_of_your_chosing_WITHOUT_FILE_EXTENSION', videoElem).then((success)=>{
  // We can stream. Start the video or do something else
  videoElem.play();
}, (rejected)=>{
  // Streaming not possible, fallback
});
```
### streamedbyfaster.js
Just like `streamedby.js` but this one uses files generated by the lastest (v2.0) version of Streamby:ify. It will generate a `dashparams.json` file that you can import or copy/paste and pass as parameters to `StreamedByFaster`. It does also support passing in an optional `m3u8` manifest as a string. If you choose not to, it will try to fetch it from the server. Usage:
```js
import { StreamedByFaster } from './streamedbyfaster'
import { m3u8String } from './asset/m3u8string'
const videoElem = document.querySelector('video')

const params = {"duration":15,"codecsString":"avc1.64001E,mp4a.40.2","numberOfSegments":15,"name":"telia","baseUrl":"https://ibv.streamedby.com/pontus/testing/telia/"};
StreamedByFaster(params, videoElem, m3u8String).then(startStream, streamingNotPossible);
```

### autoplay.js
`autoplay.js` exports a function, `checkIfAutoplayIsSupported`, that runs a test to see if muted autoplay is supported by the browser. To make it work, you will need to add this element to your html: `<video id="ap-test" playsinline muted webkit-playsinline width="1" height="1"></video>` (this element will, by default, be removed after the test is run). The element **needs to be in the DOM when the file loads** or else the autoplay test **will always fail in Chrome**.

```js
checkIfAutoplayIsSupported().then(success=>{
  // Autoplay is supported. Everything is cool and fine.
},fail=>{
  // Autoplay is not supported, fallback to some other thing
});
```
## playerutils.js
The class `PlayerUtils` exposes a set of functions that can be handy. Use if you like.

#### Examples PlayerUtils
Use `play()` & `pause()` to avoid `The play() request was interrupted by a call to pause()` [errors]((https://developers.google.com/web/updates/2017/06/play-request-was-interrupted).
```js
const playerUtils = new PlayerUtils(refToVideoElem);
playerUtils.play();
playerUtils.pause();
```
`whenLoading.show.element` hides an element (with `opacity: 0` and `pointer-events: none`) and shows it again whenever the video is in `waiting` state:
```js
playerUtils.whenLoading.show.element(refToLoadingAnimation)
```
### Polyfills needed

`StreamedBy` is built with `Promise`'s and `fetch`. Both of these will have to be polyfilled to support outdated browsers.

## Documentation
To build documentation, run `npm run build-jsdoc`.

## Statistik, exempel
```js
import {PlayerUtils} from './modules/playerutils';
import getSafeFrameInViewUpdates from './modules/safeframe_inview';

const playerUtils = new PlayerUtils(videoElement),
  timingCues = {
    "firstQ": 2.5,
    "secondQ": 5,
    "thirdQ": 7.5,
    "fourthQ": 9.5
  };

if (Enabler.isInitialized()) {
  enablerInitHandler();
} else {
  Enabler.addEventListener(studio.events.StudioEvent.INIT, enablerInitHandler);
}

function enablerInitHandler() {
  // Sätt ingång StreamedBy etc etc...

  // Parametrar: annonsens bredd, höjd, callback, minimum procent för att räknas som inview
  const safeFrameAvailable = getSafeFrameInViewUpdates(1, 1, inviewUpdates, 50);
  if (!safeFrameAvailable) {
    //skicka statistik om att vi inte kan mäta inview och därmed inte mäta hur mkt som setts av videon på ett bra sätt
    //firetracker
    track.counter('nosafeframe');
    //Enabler
    Enabler.counter('nosafeframe');
  } else {
    // Få uppdateringar om hur mycket av videon som setts. Skicka in ett objekt med timestamps. Se timingCues
    // för 25, 50, 75 och 100 procent (Obs! sista får inte vara riktigt 100% utan minst 0.2 sekunder innan full tid av videon). Ett sånt här objekt skapas automatiskt av streamby:ify
    playerUtils.getTimingUpdatesOnce(timingCues, timing => {
      //timing === firstQ || secondQ || thirdQ || fourthQ
      track.counter(timing);
      Enabler.counter(timing);
    });
    // Denna funktion måste anropas för att sätta ingång timingupdates
    playerUtils.startListeningToCues();
  }

}
// Play/pausa videon beroende på om den är inview eller inte
function inviewUpdates(inview) {
  if (inview) {
    playerUtils.play();
  } else {
    playerUtils.pause();
  }
}
```

## TVOV

Measure video advertisements ‘Total TV and Video Rating’ (TVOV). Which are a system that will measure TV set viewing, IP/streaming TV and out-of-home viewing in one combined service.


#### ! This should be used __only__ and __always__ on production for TV2 

To use this module import the `springstreams.js` file. This file handel all the tracking and measurement, you as a developer has to only hook it up to the video element and supply meta data.

### Example HTML5 video

Import the SpringStreams 
```js
import SpringStreams from './modules/springstreams';
```
The springstreams-functions are available via  SpringStreams class. During creation of an object in this class, the website-identification is transferred. (should always be tv2stream)
```js
const sensors = new SpringStreams("tv2stream");
```
In addition to the ID of the object to be measured, descriptive information concerning the object in form of Javascript-object can be indicated. The important part is the `cq` parameter where the SPOTID should go. This ID is supplyed by TV2 prior to project start. And the `stream` parameter that must start with `play/odm/tv_2_online/ad/ibv/` folowed by advertiser and campaign name. (url encoded)
```js
const description = {
      "stream": "play/odm/tv_2_online/ad/ibv/telia",
      "ct": "stremedby",
      "cq": "SPOTID123"
  };
```
A video element can now be measured directly. In order to perform the measurement, the object to be measured is needed. Usually this is available via the id of the object-tag. In this example, the object with the ID `video` is used with a reference to an HTML video element.
```js
const handle = sensors.track(video, description, sensors.HTML5Adapter);
```

Documentation to implement the Streaming Tag:
https://kantarmedia.atlassian.net/wiki/spaces/public/pages/159727129/Norwegian+Internet+Project#NorwegianInternetProject-ProjectOverview
https://kantarmedia.atlassian.net/wiki/spaces/public/pages/159726917/Implementation+of+Stream+Measurement
